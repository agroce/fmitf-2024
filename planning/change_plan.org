* Major points from the reviews

1. Comparison with previous work, e.g., "Modelisation of Timed Automata in Coq" by Christine Paulin-Mohring, Coq's code extraction capabilities, various works on implementing TA in Coq.
   a. A comment on Verdi that its limitation in addressing timing is not fundamental and can be overcome. How are we address that comment? We need to emphasize more / make a better case why Verdi is not suitable.

2. The focus is too narrow on communication protocols in embedded systems like SEGA.

3. Lacks technical details and / or examples of translating from formal models to specs, ghost code, etc.

* Todo

** SEGA [0/4]
- [ ] Get more info about SEGA complexity and structure
- [ ] Introduce SEGA (and define the acronym) better, focusing on the problem, its complexity and impacts
- [ ] Should mention that we have complete access to SEGA, including the code (link), its hardware, etc. to carry out the full case study.
- [ ] Restructure SEGA case study section to make it easier to follow / understand, especially the tasks and the approach.

** Robotics application [0/3]
- [ ] Beginning: write that the methodology and tools developed in this project are applicable to other applications, give examples, and that we are planning to perform case studies on both SEGA and robotics system, so it's not limited to SEGA and communication protocol.
- [ ] Write a section on autonomous robots / multi-agents application: the experiment, will use ICONS Lab, what kind of issues that we can apply the research outputs on, what we will get out, etc.
- [ ] Add this case study to budgets and plan (year 3).

** Broader impact [0/3]
- [ ] Add Frederic's course
- [ ] Add Alex's planned course
- [ ] Add Truong's planned course on autonomous vehicles, for which tools developed in this project can be applied and taught to engineers who may not be very familiar with formal methods and software testing.

* Plan

** Motivation and Goals

I think the motivation should be improved to better explain the scope and the approach taken in our proposal.

- Make it super clear that our work targets general embedded systems. We select the communication protocol problem & SEGA case study as it's a difficult problem and representative of problems in embedded systems (timing and coordination between different subsystems).  Somehow our current writing causes the impression that our work only focuses on communication protocol in SEGA.

- Make it clear that we target existing code, not auto-generating (provenly correct) code from formal models:
  - Because existing code in existing systems are abundant, we don't want them to be rewritten just to utitlize code generation tools.
  - Because those auto code generation tools are not sufficient: real embedded systems usually require peripheral code (library calls, I/O interface with physical world,...) not generated by these tools and can affect the final systems.  We need to be careful here because there are tools (such as Matlab/Simulink embedded code generation tools) that can generate full system code; however they are not formally verified and we have to trust the vendor.

- Make it very clear that we target users who are embedded system engineers, who don't know and don't want to learn Coq.  Therefore, our approach aims to create automated tools that don't require any or deep knowledge of Coq / interactive provers.  That's different from many other tools / approaches.  Our NFM 2019 (http://dx.doi.org/10.1007/978-3-030-20652-9_6) paper shows that it is possible to get rid of Coq.

- We need to find different ways to express our goals so we can repeat that several times in the proposal.


** Related work

I'm not very familiar with the aforementioned related work (in Coq, Ocaml, Verdi), but we should clearly distinguish our approach with those.

- Basically all Coq related work is non relevant: we don't want IoT engineers learn Coq to design systems!  However, there was one caveat in using Frama-C: sometimes Coq was required to write some proofs when automated provers fail.  Our NFM 2019 (http://dx.doi.org/10.1007/978-3-030-20652-9_6) paper shows that it is possible to get rid of Coq.


** Technical details

1. As I understand, we don't aim to verify that the code satisfies certain temporal logic specifications (that's done by the formal modeling and verification tools like UPPAAL).  Rather, we aim to verify that the code "faithfully" implements the timed automata.  How do we define that explicitly?  How are the Coq annotations (pre-conditions, post-conditions, etc.) and ghost code able to verify that?  What types of new annotations will be needed?  I think we should provide a bit more details.

2. What kinds of timed automata will we consider?  The full TA specs of UPPAAL (which can be quite complex with local variables, user-defined functions, broadcasting, etc.) or a simpler version?  Or will we develop our approach on increasingly complex TA specs, starting from the basic (Alur's and Dill's TA) to the UPPAAL TA?

3. I don't know about previous related work in Coq, but ours targets real embedded systems, so non-determinism will be an issue, especially related to I/O with physical world.  We briefly wrote about the timing aspect in the context of WCET and parallel C programs.  We should also directly address the temporal non-determinism of the outside world:
   - worst-case analysis
   - model world as timed automata interacting with the software system?
   - new annotations to specify temporal non-determinism of world
   - generate parallel ghost code to represent world?

4. We need more discussion on some principles of generating annotations and ghost code (related to point 1 above).  It's best to present a simple example.  I'd suggest we take a very simple communication protocol example implemented in UPPAAL / TA and work out the C code, annotations, ghost code.  I think this would immensely improve our proposal.

5. Risk analysis: we should write about the risks involved (our proposed approach doesn't work then what are the alternatives?)

6. See more technical discussion in [[* Technical principles]]


** Applications / Case study

Should we have other applications in addition to SEGA?

- Some years ago I read a paper on control communication protocol for high-speed trains formally verified by UPPAAL.  A potential simulation-based case study?

- Manufacturing automation involves a lot of precise timed sequences.  Potentially a good non-communication-related case study, to illustrate that our work is not limited to communication protocols.  Possible issues: simulation only (we can have a Capstone team build a desktop scale manufacturing testbed, easy and fun); most manufacturing automation systems are not written in C family but use PLCs (Programmable Logic Controllers) and specialized languages (e.g., SFC - Sequential Function Charts - for finite state machines).

- Robot task coordination: I have a research drone system in my lab.  We can consider code to control a drone, or multiple drones, to carry out tasks that are planned at high level as timed automata.  This application could be real experiments, but it will require extra human resource (student effort to work on the drone experiments) and can be quite sophisticated.


** Others

- Should add Frederic's and Truong's prior NSF support: none.

* Technical principles

** Implementation model of timed automata

There are different ways / models of implementing TAs in code, for example:
- Define constants (enums) for different states and implement each TA as a big =if-else= or =switch-case= structure (if in this state and this event occurs and some conditions are met then change to another state and do something).
- Use OOP (or emulate OOP): each class represents one state or one type of states; each class defines an execution method to process events and conditions and execute actions; the state machine is implemented as running the executation method on the current state object, utilizing dispatching in OOP.


Two questions:
1. Will we restrict to one or a few implementation methods? Which ones?
2. For each method, we may need to develop a different way to annotate the code and describe specifications; we may even need a different set of annotations, etc.  Is there a unified method?
