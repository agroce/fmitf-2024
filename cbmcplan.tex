While automated test generation by fuzzing or binary-level symbolic execution can be highly effective as a means for finding bugs in code, other approaches are also needed to handle the kinds of code especially common in embedded contexts.  In particular, embedded software often includes a large number of functions that perform complex low-level bit operations, especially for interacting with hardware and ``parsing'' network packets (from traditional wireless or RF-derived signals).  Fuzzing or binary symbolic analysis often has trouble  finding exact bit-values; it is well known that, e.g., inverting even non-cryptographic hashes is hard.  Translation to SAT or SMT, however, often easily handles such problems.

CBMC, the C Bounded Model Checker~\cite{cbmcp} is a well-known tool that analyzes C programs using a translation to SAT or SMT queries based on a bounded unrolling of loops. CBMC is an actively developed project, and has been used extensively in real-world development for years, including in automotive/embedded code development at Bosch and General Electric~\cite{tiemeyer2019crest}, in analysis of Amazon Web Services infrastructure~\cite{awsmodel}, and in the analysis of flight software systems at NASA's Jet Propulsion Laboratory~\cite{AMAI}.  Using CBMC requires writing custom test harnesses using CBMC's API for expressing nondeterminism, and running the tool with a specified bound on loop executions, in addition to other complex configuration options.

We propose to allow CBMC to be used as a backend for verification by DeepState, with a seamless interface, just as DeepState currently supports symbolic analysis engines such as angr and Manticore.  It is notoriously hard to guess when a SAT/SMT based approach to code analysis will work well and when it will fail to scale; using a DeepState harness will allow users to try CBMC at ``no cost.''

Moreover, because choosing loop unwinding bounds imposes a serious burden on embedded engineers, we will investigate their automatic determinations.  One approach is to instrument fuzzer or symbolic-execution engine generated tests to record iterations of loops, and then use the maximum bound observed.  Additionally, for small functions (the most likely targets for DeepState-CBMC: complex but compact bit-manipulation code), the mutation-based approach proposed by Groce et. al~\cite{groce2018verified} may work.  Finally, in some cases CBMC may be able to find interesting bugs for cases where the loop unrollings are limited, but cannot scale to larger depth limits.  Using the same instrumentation that we use to estimate loop bounds, we will use the ability to guide fuzzers by alternative ``coverage'' to focus fuzzer runs on executions with more loop iterations than the bound explored by CBMC.  This will offer engineers a true partnership between verification methods. 