While \framac{} provides powerful tools for static detection of program faults and generation of runtime checks for properties that cannot be discharged by formal proof or sound static analysis, it provides only limited, and difficult-to-scale, ability to generate program inputs to exercise runtime checks, limited to one tool, PathCrawler~\cite{WilliamsMMR05EDCC}, that aims to produce a unit test for a single function, using concolic testing (dynamic symbolic execution~\cite{GodefroidKS05}).  In cases where this fails to scale, PathCrawler will fail.  Furthermore, PathCrawler is tuned to the problem of testing a single function, not producing more complex scenario-based tests of a set of functions that must coordinate state changes.  Finally, PathCrawler is not an open source, extensible system, may be costly to acquire and use, and is arguably impossible to extend.

The limitation of dynamic analysis tools to PathCrawler is a major weakness of \framac from the perspective of a user.  Scalability of symbolic-execution-based test generation methods is extremely difficult to predict, and producing complete and exhaustive preconditions that allow a function to be tested entirely in isolation is often either too time-consuming or essentially impossible, because the actual environment is only represented by the set of states reachable using a set of coordinating functions or a library.  These problems are pressing, for several reasons.  First, full formal proof of correctness is, at present, impractical for most realistic systems.  The actual work of fault detection and validation of software still relies, fundamentally, on effective testing.  Moreover, modeling and even static approaches often must rest on a basis of numerous un-examined assumptions about the behavior of hardware systems and low-level system behavior.  Only actual concrete inputs can be executed on real hardware, and satisfy regulatory requirements on code coverage such as those imposed on civilian avionics by DO-178B, etc.~\cite{MCDC}.  Furthermore, only testing can prove faults are not spurious, the result of imprecise abstraction or weak assumptions.

%DeepState~\cite{DeepState} is a dynamic analysis tool that aims to provide a single, usable, flexible front-end to a wide variety of back-end systems for test generation.
Most developers do not know how to use symbolic execution tools; developers seldom even know how to use less challenging tools such as gray-box fuzzers, even relatively push-button ones such as AFL~\cite{aflfuzz}.  Even those developers whose primary focus is critical security infrastructure such as OpenSSL are often not users, much less expert users, of such tools.  Furthermore, different tools find different faults, have different scalability limitations, and even have different show-stopping bugs that prevent them from being applied to specific testing problems.  DeepState~\cite{DeepState,DeepStateTutorial} addresses these problems.  First, developers \emph{do}, usually, know how to use unit testing frameworks, such as JUnit~\cite{JUnit} or Google Test~\cite{GoogleTest}. DeepState makes it possible to write parameterized unit tests~\cite{ParamUnit} in a GoogleTest-like framework, and automatically produce tests using symbolic execution tools~\cite{angr1,angr2,angr3,Manticore}, or fuzzers like AFL~\cite{aflfuzz} or libFuzzer~\cite{libFuzzer} (as well as Eclipser~\cite{eclipser}, Angora~\cite{angora}, and Honggfuzz~\cite{Honggfuzz}).  DeepState targets the same space as property-based testing tools such as QuickCheck~\cite{ClaessenH00}, ScalaCheck~\cite{ScalaCheckDoc}, Hypothesis~\cite{Hypothesis}, and TSTL~\cite{NFM15,tstlsttt}, but for C/C++ unit tests. DeepState is, most importantly, the first tool to provide a front-end that can make use of a growing variety of back-ends for test generation.  Developers who write tests using DeepState can expect that DeepState will let them, without rewriting their tests, make use of new symbolic execution or fuzzing advances.  The harness/test definition remains the same, but the method(s) used to generate tests may change over time.  Most property-based tools only provide random testing, and symbolic execution tools such as Pex~\cite{Pex,UnitMeister} or KLEE~\cite{KLEE} offer only a single back-end.
DeepState has already been used to test (and find bugs in) an ext3-like file system~\cite{testfs,testfsrepo} and a widely used compression library, and is being actively explored as a basis for automatic testing for in NASA's open source flight software framework FPrime~\cite{fprime,fprimerepo}.  Although only released in early 2018, DeepState is already one of the most popular property-based testing and fuzzing projects on GitHub, and has been used internally by both startups and well-established companies, and in security audits by Trail of Bits.  There have even been informal discussions of integrating DeepState, once matured, into a future release of the GoogleTest~\cite{GoogleTest} platform.  PI Groce is at present the lead developer for DeepState.